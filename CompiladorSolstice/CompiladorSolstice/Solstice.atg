#include "Tabla.h"
#include "Cubo.h"
#include <iostream>
#include <sstream>
COMPILER Solstice
CTABLE dirProc;
TABLE dirGral;
Cubo c;
CVariable o1;
CVariable o2;
stack<int> oper;
stack<CVariable> operandos;
stack<int> saltos;
stack<int> ifs;
vector<int> t_params;
vector<Cuadruplo> gen;

int type;
int ctype;
int vis;
int dim;
int availNum;
string name;
string className;
bool err;

string conv(wchar_t* x){
	std::wstring ws(x);
	string s(ws.begin(), ws.end());
	s.assign(ws.begin(), ws.end());
	return s;
};

string avail(){
    stringstream s;
    s << "t" << availNum;
    return s.str();
}

string avail2(int al){
    stringstream s;
    s << "" << al;
    return s.str();
}

CHARACTERS
  letra = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz".
  letraU = "ABCDEFGHIJKLMNOPQRSTUVWXYZ".
  digito = "0123456789".
  rc  = '\r'.
  sl  = '\n'.
  tab = '\t'.
  otrosC = ANY - '/' - '*'.
  otrosS = ANY - '"' - rc - sl - tab.
	
TOKENS
  idV = '_'letra {letra | digito}. /* Id Variable */
  idM = '#' letra {letra | digito}. /* Id Metodo */
  idO = letraU {letra | digito}. /* Id Objeto Nombre de la Clase */
  idC = '$' letraU {letra | digito}. /* Id Constructor */
  cteI = digito {digito}.
  cteD = digito {digito} "." digito {digito} .
  cteS = '\"' otrosS {otrosS} '\"'.
  cteB = "true" | "false".
  tCla = "class".
  tPub = "public".
  tPri = "private".	
  tPro = "protect".	
  tRet = "return".		
  tStr = "string".		
  tInt = "int". 		
  tDou = "double".
  tBoo = "bool".		
  tNew = "new".		
  tVoi = "void".		
  tCon = "if" | "?".		
  tEls = "else" | ":".
  tEif = "elseif" | ":?".  
  tWhi = "while" | "@".
  tExt = '-''>'.
  tMai = "main".
  tLec = '>''>'.
  tEsc = '<''<'.
  tInc = '+''+'.
  tDec = '-''-'.
  tMay = '>''='.
  tMen = '<''='.
  tDif = '<''>'.
  tEqu = '=''='.

PRAGMAS
	comentarios = "/*" {'/' | otrosC | '*' {'*'} otrosC} '*' {'*'} '/'.
	
IGNORE rc + sl + tab

PRODUCTIONS
	Solstice = (. c = Cubo(); availNum = 0;.)Class Main.
	
	Arr = '[' (idV | cteI) ']' (. dim = 1; .).
	
	Asig = ((tInc (.if(o1.var_type == INT){
					gen.push_back(Cuadruplo(SUM, o1.name, "1" , o1.name));
				} else {
				cout << "TYPE MISMATCH! :" << o1.name << '\n';
				err = TRUE;
				}.)| 
			tDec (.if(o1.var_type == INT){
					gen.push_back(Cuadruplo(SUB, o1.name, "1" , o1.name));
				} else {
				cout << "TYPE MISMATCH! :" << o1.name << '\n';
				err = TRUE;
				}.)| 
			Asig2) | Arr Asig2) ';'.
	
	Asig2 = '=' ExpOY (.if(c.cubo[operandos.top().var_type][o1.var_type][ASI] != -1){
							gen.push_back(Cuadruplo(ASI, operandos.top().name, "" , o1.name));
							operandos.pop();
						} else {
						cout << "TYPE MISMATCH! :" << o1.name << '\t' << o2.name << '\n';
						err = TRUE;
						}.).
	
	Atributo = Vis Tipo idV (.	name = conv(t->val);
								if(dirProc.find(name) == dirProc.end()){
									dirProc.insert(CTABLE::value_type(name, Attribute(vis, type, 0)));
									name = "";
									vis = type = -1;
								} else {
									cout << "PREVIOUSLY DECLARED ATTRIBUTE: " << name << '\n';
								err = TRUE;
								}
							.)';'.
	
	Bloque = Atributo{Atributo} Constructor {Vis (MetodoR | MetodoV)}.
	
	Ciclo = tWhi (.saltos.push(gen.size());.) '(' 
			ExpOY ')' (.CVariable boolRes = operandos.top();
						operandos.pop();
						if(boolRes.var_type != BOOLEAN){
							cout << "EXPRESSION MUST BE BOOL TYPE!\n";
						}else{
							gen.push_back(Cuadruplo(GTF, boolRes.name, "" , ""));
							saltos.push(gen.size() - 1);
						}.)	'{' {Estatuto} 
			'}' (.int falso = saltos.top();
				saltos.pop();
				int ret = saltos.top();
				saltos.pop();
				gen.push_back(Cuadruplo(GTO, avail2(ret), "" , ""));
				gen[falso].res = avail2(gen.size());
				.).
	Class = (.string ext = "";.)
			tCla idO (. className = conv(t->val); .) 
			[tExt idO (. ext = conv(t->val);.)] 
			'{' Bloque '}' (.if(dirGral.find(className) == dirGral.end()){
								dirGral.insert(TABLE::value_type(className, ClassStruct(ext, dirProc)));
								className = "";
								dirProc.clear();
							}.)
			[Class].
	
	Con = 	tCon (.ifs.push(1);.)
			'(' ExpOY ')'  (.CVariable boolRes = operandos.top();
							operandos.pop();
							if(boolRes.var_type != BOOLEAN){
							cout << "EXPRESSION MUST BE BOOL TYPE!\n";
							}else{
							gen.push_back(Cuadruplo(GTF, boolRes.name, "" , ""));
							saltos.push(gen.size() - 1);
							}.)
			'{' Estatuto {Estatuto} '}' 
			{ tEif (.int ps = saltos.top();
					saltos.pop();
					gen.push_back(Cuadruplo(GTO, "", "" , ""));
					saltos.push(gen.size() - 1);
					gen[ps].res = avail2(gen.size());.)
			'(' ExpOY ')' (.ifs.top()++;
							CVariable boolRes = operandos.top();
							operandos.pop();
							if(boolRes.var_type != BOOLEAN){
							cout << "EXPRESSION MUST BE BOOL TYPE!\n";
							}else{
							gen.push_back(Cuadruplo(GTF, boolRes.name, "" , ""));
							saltos.push(gen.size() - 1);
							}.)
			'{' Estatuto {Estatuto} '}'}.
	
	Con2 = 	tEls (.if(gen[saltos.top()].operador != GTO){
				int ps = saltos.top();
				saltos.pop();
				gen.push_back(Cuadruplo(GTO, "", "" , ""));
				gen[ps].res = avail2(gen.size());
				saltos.push(gen.size() - 1);
				}.)
			'{' Estatuto {Estatuto} '}'.
	
	ConG = 	Con [Con2](.int gts = ifs.top();
						ifs.pop();
						while(gts > 0){
						int ps = saltos.top();
						saltos.pop();
						if(gen[ps].operador == GTO)
							gen[ps].op1 = avail2(gen.size());
						else if (gen[ps].operador == GTF)
							gen[ps].res = avail2(gen.size());
						gts--;
						}.).
	
	Constructor = idC 	(.	name = conv(t->val);
						if(dirProc.find(name) == dirProc.end()){
							dirProc.insert(CTABLE::value_type(name, Attribute(PUBLIC, OBJECT, 1)));
							vis = type = -1;
						} else {
							cout << "CANNOT DECLARE MORE THAN ONE CONSTRUCTOR." << '\n';
							err = TRUE;
						}
						.)'(' [Param] ')' '{' {Init} '}'.
	
	CTE = cteS (. ctype = 2; .)| cteI (. ctype = 0; .)| cteD (. ctype = 1; .)| cteB (. ctype = 3; .).
	
	CTES (. string temp; .)
		= idV (.temp = conv(t->val);
				if(dirProc[name].vars.find(temp) != dirProc[name].vars.end()){
					o2.name = temp;
					o2.var_dim = dirProc[name].vars.find(temp)->second.var_dim;
					o2.var_type = dirProc[name].vars.find(temp)->second.var_type;
				}.)| 
			CTE(.temp = conv(t->val);
			o2.name = temp;
			o2.var_dim = 0;
			o2.var_type = ctype;
			.).
	
	Decl (. string nameL;.) 
		= (New | Tipo idV (. nameL = conv(t->val); .)
		  ( '=' CTES | Arr) (.
							if(( dirProc.find(nameL) == dirProc.end()) && 
								(dirProc[name].vars.find(nameL) == dirProc[name].vars.end())){
								dirProc[name].vars.insert(VMAP::value_type(nameL, Variable(type, dim)));
								dim = 0;
							} else {
								cout << "PREVIOUSLY DECLARED VARIABLE: " << nameL << '\n';
								err = TRUE;
							}
							if(c.cubo[o2.var_type][type][ASI] != -1){
								gen.push_back(Cuadruplo(ASI,o2.name, "" , nameL));
							} else {
								cout << "TYPE MISMATCH! :" << nameL << '\t' << o2.name << '\n';
								err = TRUE;
							}
							.) 
		  {',' idV (. nameL = conv(t->val); .) 
		  ( '=' CTES | Arr )(.
							if(( dirProc.find(nameL) == dirProc.end()) && 
								(dirProc[name].vars.find(nameL) == dirProc[name].vars.end())){
								dirProc[name].vars.insert(VMAP::value_type(nameL, Variable(type, dim)));
								dim = 0;
							} else {
								cout << "PREVIOUSLY DECLARED VARIABLE: " << nameL << '\n';
								err = TRUE;
							}
							if(c.cubo[o2.var_type][type][ASI] != -1){
								gen.push_back(Cuadruplo(ASI,o2.name, "" , nameL));
							} else {
								cout << "TYPE MISMATCH! :" << nameL << '\t' << o2.name << '\n';
								err = TRUE;
							}
							.)}) ';'.
	
	Esc = tEsc '(' ExpOY {(.if(!oper.empty() && oper.top() == APP){
								CVariable o2 = operandos.top();
								operandos.pop();
								CVariable o1 = operandos.top();
								operandos.pop();
								int op = oper.top();
								oper.pop();
								if(c.cubo[o1.var_type][o2.var_type][op] != -1){
									gen.push_back(Cuadruplo(op,o1.name,o2.name, avail()));
									operandos.push(CVariable(avail(),c.cubo[o1.var_type][o2.var_type][op],0));
									availNum++;
								} else {
									cout << "TYPE MISMATCH! :" << o1.name << '\t' << o2.name << '\n';
									err = TRUE;
								}
							}
					.)'^'(.oper.push(APP);.) 
					ExpOY}(.if(!oper.empty() && oper.top() == APP){
								CVariable o2 = operandos.top();
								operandos.pop();
								CVariable o1 = operandos.top();
								operandos.pop();
								int op = oper.top();
								oper.pop();
								if(c.cubo[o1.var_type][o2.var_type][op] != -1){
									gen.push_back(Cuadruplo(op,o1.name,o2.name, avail()));
									operandos.push(CVariable(avail(),c.cubo[o1.var_type][o2.var_type][op],0));
									availNum++;
								} else {
									cout << "TYPE MISMATCH! :" << o1.name << '\t' << o2.name << '\n';
									err = TRUE;
								}
							}
							.) ')' 
				(.CVariable strRes = operandos.top();
				operandos.pop();
				if(strRes.var_type != STRING){
					cout << "EXPRESSION MUST BE STRING TYPE!\n";
				}else{
					gen.push_back(Cuadruplo(WRI, strRes.name, "" , ""));
				}.)';'.
	
	Estatuto = (idV (.string temp = conv(t->val); 
					if(dirProc.find(temp) != dirProc.end()){
						o1.name = temp;
						o1.var_dim = 0;
						o1.var_type = dirProc.find(temp)->second.att_type;
					}else if (dirProc[name].vars.find(temp) != dirProc[name].vars.end()){
						o1.name = temp;
						o1.var_dim = 0;
						o1.var_type = dirProc[name].vars.find(temp)->second.var_type;
					}else {
					cout << "UNDECLARED VARIABLE: " << temp << '\n';
					err = TRUE;
					}.) 
				(Asig | Reg)) | Metodo ';' | Ciclo | Esc | Lec | ConG.
	
	Exp = Termino {(.if(!oper.empty() && (oper.top() == SUM || 
						oper.top() == SUB)){
							CVariable o2 = operandos.top();
							operandos.pop();
							CVariable o1 = operandos.top();
							operandos.pop();
							int op = oper.top();
							oper.pop();
							if(c.cubo[o1.var_type][o2.var_type][op] != -1){
								gen.push_back(Cuadruplo(op,o1.name,o2.name, avail()));
								operandos.push(CVariable(avail(),c.cubo[o1.var_type][o2.var_type][op],0));
								availNum++;
							} else {
								cout << "TYPE MISMATCH! :" << o1.name << '\t' << o2.name << '\n';
								err = TRUE;
							}
						}
					.)
					('+' (. oper.push(SUM); .) | 
					'-' (. oper.push(SUB); .)) Termino}
					(.if(!oper.empty() && (oper.top() == SUM || 
						oper.top() == SUB)){
							CVariable o2 = operandos.top();
							operandos.pop();
							CVariable o1 = operandos.top();
							operandos.pop();
							int op = oper.top();
							oper.pop();
							if(c.cubo[o1.var_type][o2.var_type][op] != -1){
								gen.push_back(Cuadruplo(op,o1.name,o2.name, avail()));
								operandos.push(CVariable(avail(),c.cubo[o1.var_type][o2.var_type][op],0));
								availNum++;
							} else {
								cout << "TYPE MISMATCH! :" << o1.name << '\t' << o2.name << '\n';
								err = TRUE;
							}
						}
					.).
	
	ExpOY = Expresion {(.if(!oper.empty() && (oper.top() == AND || 
						oper.top() == OR)){
							CVariable o2 = operandos.top();
							operandos.pop();
							CVariable o1 = operandos.top();
							operandos.pop();
							int op = oper.top();
							oper.pop();
							if(c.cubo[o1.var_type][o2.var_type][op] != -1){
								gen.push_back(Cuadruplo(op,o1.name,o2.name, avail()));
								operandos.push(CVariable(avail(),c.cubo[o1.var_type][o2.var_type][op],0));
								availNum++;
							} else {
								cout << "TYPE MISMATCH! :" << o1.name << '\t' << o2.name << '\n';
								err = TRUE;
							}
						}
						.)
						('&' (. oper.push(AND); .)| 
						'|' (. oper.push(OR); .)) Expresion}
						(.if(!oper.empty() && (oper.top() == AND || 
						oper.top() == OR)){
							CVariable o2 = operandos.top();
							operandos.pop();
							CVariable o1 = operandos.top();
							operandos.pop();
							int op = oper.top();
							oper.pop();
							if(c.cubo[o1.var_type][o2.var_type][op] != -1){
								gen.push_back(Cuadruplo(op,o1.name,o2.name, avail()));
								operandos.push(CVariable(avail(),c.cubo[o1.var_type][o2.var_type][op],0));
								availNum++;
							} else {
								cout << "TYPE MISMATCH! :" << o1.name << '\t' << o2.name << '\n';
								err = TRUE;
							}
						}
						.).
	
	Expresion = Exp [(.if(!oper.empty() && (oper.top() == GEQ || 
						oper.top() == LEQ || oper.top() == DIF ||
						oper.top() == LT || oper.top() == GT ||
						oper.top() == EQ)){
							CVariable o2 = operandos.top();
							operandos.pop();
							CVariable o1 = operandos.top();
							operandos.pop();
							int op = oper.top();
							oper.pop();
							if(c.cubo[o1.var_type][o2.var_type][op] != -1){
								gen.push_back(Cuadruplo(op,o1.name,o2.name, avail()));
								operandos.push(CVariable(avail(),c.cubo[o1.var_type][o2.var_type][op],0));
								availNum++;
							} else {
								cout << "TYPE MISMATCH! :" << o1.name << '\t' << o2.name << '\n';
								err = TRUE;
							}
						}
					.)
					(	tMay (. oper.push(GEQ); .)| 
						tMen (. oper.push(LEQ); .)| 
						tDif (. oper.push(DIF); .)| 
						'<' (. oper.push(LT); .)| 
						'>' (. oper.push(GT); .)| 
						tEqu (. oper.push(EQ); .)) Exp ]
					(.if(!oper.empty() && (oper.top() == GEQ || 
						oper.top() == LEQ || oper.top() == DIF ||
						oper.top() == LT || oper.top() == GT ||
						oper.top() == EQ)){
							CVariable o2 = operandos.top();
							operandos.pop();
							CVariable o1 = operandos.top();
							operandos.pop();
							int op = oper.top();
							oper.pop();
							if(c.cubo[o1.var_type][o2.var_type][op] != -1){
								gen.push_back(Cuadruplo(op,o1.name,o2.name, avail()));
								operandos.push(CVariable(avail(),c.cubo[o1.var_type][o2.var_type][op],0));
								availNum++;
							} else {
								cout << "TYPE MISMATCH! :" << o1.name << '\t' << o2.name << '\n';
								err = TRUE;
							}
						}
					.).
	
	Factor =  ['~'|'-'] ( '(' (.oper.push(99);.) ExpOY ')' (.oper.pop();.)| 
				idV (.	string temp = conv(t->val);
						if(dirProc.find(temp) != dirProc.end()){
							operandos.push(CVariable(temp, dirProc.find(temp)->second.att_type, dirProc.find(temp)->second.att_mtd));
						} else if(dirProc[name].vars.find(temp) != dirProc[name].vars.end()){
							operandos.push(CVariable(temp, dirProc[name].vars.find(temp)->second.var_type, dirProc[name].vars.find(temp)->second.var_dim));
						} else {
							cout << "UNDECLARED VARIABLE: " << temp << '\n';
							err = true;
						}
					.)[Reg|Arr] | 
					CTE (.
						string temp = conv(t->val);
						operandos.push(CVariable(temp, ctype, 0));
					.) | Metodo).
	
	Init = idV (.string temp = conv(t->val); 
				if(dirProc.find(temp) != dirProc.end()){
					o1.name = temp;
					o1.var_dim = 0;
					o1.var_type = dirProc.find(temp)->second.att_type;
				}else{
				cout << "UNDECLARED VARIABLE: " << temp << '\n';
				err = TRUE;
				}.)  
			'=' CTES (.if(c.cubo[o2.var_type][o1.var_type][ASI] != -1){
						gen.push_back(Cuadruplo(ASI,o2.name, "" , o1.name));
					} else {
						cout << "TYPE MISMATCH! :" << o1.name << '\t' << o2.name << '\n';
						err = TRUE;
					}
					.)';'.
	
	Lec = tLec '(' idV (.string temp = conv(t->val); 
						if(dirProc.find(temp) != dirProc.end()){
							o1.name = temp;
							o1.var_dim = 0;
							o1.var_type = dirProc.find(temp)->second.att_type;
						}else if (dirProc[name].vars.find(temp) != dirProc[name].vars.end()){
							o1.name = temp;
							o1.var_dim = 0;
							o1.var_type = dirProc[name].vars.find(temp)->second.var_type;
						}else {
						cout << "UNDECLARED VARIABLE: " << temp << '\n';
						err = TRUE;
						}
						if(o1.var_type == STRING){
						gen.push_back(Cuadruplo(REA,o1.name, "" , ""));
						} else {
						cout << "TYPE MISMATCH! :" << o1.name << '\n';
						err = TRUE;
						}.)
			')' ';'.
	
	Lista = CTES [',' Lista].
	
	Main = tMai (.	name = conv(t->val);
					if(dirProc.find(name) == dirProc.end()){
						dirProc.insert(CTABLE::value_type(name, Attribute(3, MAIN, 0)));
						vis = type = -1;
					} else {
						cout << "CANNOT DECLARE MORE THAN ONE MAIN." << '\n';
						err = TRUE;
					}
				.)'(' ')' '{' {Decl} {Estatuto} '}'
				(.if(dirGral.find("main") == dirGral.end()){
					dirGral.insert(TABLE::value_type("main", ClassStruct("", dirProc)));
					dirProc.clear();
				}.).
	
	Metodo = 	idM (.string name = conv(t->val);
					if(dirProc.find(name) != dirProc.end()){
					cout << "UNDECLARED METHOD: " << name << '\n';
					err = TRUE;
					}
					gen.push_back(Cuadruplo(ERA,name, "" , ""));.)
				'(' (. t_params = dirProc[name].params; .)
				[Lista] ')'
				(.gen.push_back(Cuadruplo(GSU, avail2(dirProc[name].mtd_q), "" , ""));.).
	
	MetodoR = 	Tipo idM (.	name = conv(t->val);
							if(dirProc.find(name) == dirProc.end()){
								dirProc.insert(CTABLE::value_type(name, Attribute(vis, type, 1, gen.size())));
								vis = type = -1;
							} else {
								cout << "PREVIOUSLY DECLARED METHOD: " << name << '\n';
								err = TRUE;
							}
						.) 
				'(' [Param] ')' '{' {Decl} 
				{Estatuto} Return  (.gen.push_back(Cuadruplo(MR, operandos.top().name, "", ""));
									operandos.pop();.)
				'}' (. 	name = "";
						gen.push_back(Cuadruplo(RET, "", "", ""));.).
						
	MetodoV = 	tVoi idM (.	name = conv(t->val);
							if(dirProc.find(name) == dirProc.end()){
								dirProc.insert(CTABLE::value_type(name, Attribute(vis, VOID, 1, gen.size())));
								vis = type = -1;
							} else {
								cout << "PREVIOUSLY DECLARED METHOD: " << name << '\n';
								err = TRUE;
							}
						.) 
				'(' [Param] ')' '{' {Decl} 
				{Estatuto} '}' (. name = "";
								gen.push_back(Cuadruplo(RET, "", "", ""));.).
						
	New (. string nameL; .)  
		= idO idV (.	nameL = conv(t->val);
						if((dirProc.find(nameL) == dirProc.end()) && (dirProc[name].vars.find(nameL) == dirProc[name].vars.end())){
							dirProc[name].vars.insert(VMAP::value_type(nameL, Variable(4, 0)));
						} else {
							cout << "PREVIOUSLY DECLARED VARIABLE: " << nameL << '\n';
							err = TRUE;
						}
					.)'=' tNew idC '(' [Lista] ')'.
					
	Param (. string nameL; .) 
		= Tipo idV (.	nameL = conv(t->val);
						if((dirProc.find(nameL) == dirProc.end()) && (dirProc[name].vars.find(nameL) == dirProc[name].vars.end())){
							dirProc[name].vars.insert(VMAP::value_type(nameL, Variable(type, 0)));
							dirProc[name].params.push_back(type);
						} else {
							cout << "PREVIOUSLY DECLARED VARIABLE: " << nameL << '\n';
							err = TRUE;
						}
					.)[',' Param].
					
	Reg = '.' (Metodo | idV).
	
	Return = tRet ExpOY ';'.
	
	Termino = Factor {(.if(!oper.empty() && (oper.top() == MUL || 
							oper.top() == DIV || 
							oper.top() == MOD)){
								CVariable o2 = operandos.top();
								operandos.pop();
								CVariable o1 = operandos.top();
								operandos.pop();
								int op = oper.top();
								oper.pop();
								if(c.cubo[o1.var_type][o2.var_type][op] != -1){
									gen.push_back(Cuadruplo(op,o1.name,o2.name, avail()));
									operandos.push(CVariable(avail(),c.cubo[o1.var_type][o2.var_type][op],0));
									availNum++;
								} else {
									cout << "TYPE MISMATCH! :" << o1.name << '\t' << o2.name << '\n';
									err = TRUE;
								}
							}
						.)
					(	'*' (. oper.push(MUL); .)| 
						'/' (. oper.push(DIV); .)| 
						'%' (. oper.push(MOD); .)) Factor} 
						(.if(!oper.empty() && (oper.top() == MUL || 
							oper.top() == DIV || 
							oper.top() == MOD)){
								CVariable o2 = operandos.top();
								operandos.pop();
								CVariable o1 = operandos.top();
								operandos.pop();
								int op = oper.top();
								oper.pop();
								if(c.cubo[o1.var_type][o2.var_type][op] != -1){
									gen.push_back(Cuadruplo(op,o1.name,o2.name, avail()));
									operandos.push(CVariable(avail(),c.cubo[o1.var_type][o2.var_type][op],0));
									availNum++;
								} else {
									cout << "TYPE MISMATCH! :" << o1.name << '\t' << o2.name << '\n';
									err = TRUE;
								}
							}
						.).
	
	Tipo = tInt (. type = INT; .)| 
			tDou (. type = DOUBLE; .)| 
			tStr (. type = STRING; .)| 
			tBoo(. type = BOOLEAN; .).
	
	Vis = tPub (. vis = PUBLIC; .)| 
			tPri (. vis = PRIVATE; .)| 
			tPro(. vis = PROTECT; .).
END Solstice.	